<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">

<head>

    <title>Practice JS</title>
    <link href="styles.css" rel="stylesheet" type="text/css" />
    <script src="script.js" type="module" defer></script>
    <script src="person.js" type="module"  ></script>
    <meta charset="utf-8" name="viewport" content="width=device-width, initial-scale=1.0">

</head>
<body>
    <h1>The JavaScript "this" Keyword</h1>
    <p>
        <ul>
            <li>
                // this is an object
            </li>
            <li>
                // below we will create an object and return values using the this keyword
            </li>
            <li>
                // "this" refers to the object it is in.. this object.
            </li>
            <li>
                // "this" is not a variable, it is a keyword.
            </li>
            <li>
                // When used in strict mode, "this" is undefined.
            </li>

        </ul>
    </p>


    <p>
        "this" precendence to determine which object it belongs to.
        <ol>
            <li> bind()</li>
            <li> apply() call()</li>
            <li> Local Scope </li>
            <li> Global Scope </li>

        </ol>
    </p>
    <p id="demo1"></p>
    <hr />


    <h3> Using "this" in event handlers </h3>
    <button onclick="this.style.display='none'">
        Click here to remove button
    </button>
    <hr />



    <h3> Taking a look at call() and apply()</h3>
    <p>
        call() and apply() methods
        <ul>
            <li>
                // The call() and apply() methods are predefined JavaScript methods
            </li>
            <li>
                // The call() method is just like a phone-a-friend. One object calls the other and is like "Hey what's up man, can I borrow an element?"

            </li>
        </ul>
    </p>
    <p id="demo11"></p>
    <hr />



    <h3> bind() method </h3>
    <h5> With the bind() method, and object can borrow a method from another object </h5>
    <p id="demo12"></p>
    <hr />


    <h1> Arrow Functions => </h1>
    <h5> Arrow functions were introduced to allow us to write shorter function syntax</h5>

    <p id="demo13"></p>
    <hr />

    <h3> Before Arrow </h3>
    <p id="demo14"></p>

    <h3> After Arrow</h3>
    <p id="demo15"></p>


    <h5> Don't worry, it gets shorter</h5>
    <p>The below script only works if you have one statement.</p>

    <p id="demo16"></p>
    <hr />


    <h3> Showing an arrow function with a parameter. </h3>
    <ul>
        <li> If you have parameters, you pass them inside the parentheses</li>
        <li> In fact, if you have only one parameter, you can skip the parentheses as well </li>
        <li> This handling of "this" is also different in arrow functions than regular functions. </li>
        <li> With arrow functions, there is no binding of this. </li>
    </ul>
    <p class="arrive" id="demo17"></p>
    <hr />

    <h5> What about "this" in arrow function?</h5>
    <h3> In regular functions the "this" keyword represented the object that called the function, which could be the window, the document, a button or whatever. </h3>
    <h3> With arrow functions the "this" keyword always represents the object that defined the arrow function. </h3>

    <h3> "This" within a regular function (looking at button and window examples):</h3>
    <button id="btn11"> Click Me</button>
    <p id="demo18"></p>

    <h3> "This" within an Arrow function (looking at button and window examples):</h3>
    <button id="btn12"> Click Me</button>
    <p id="demo19"></p>

    <h1> JavaScript Classes</h1>
    <p id="demo21"></p>

    <h3> JavaScript Class Methods</h3>
    <p id="demo22"></p>
    <p id="demo23"></p>


    <h1> JavaScript Modules </h1>
    <ul>
        <li> JavaScript Moduels allow you to break up your code into seperate files</li>
        <li> This makes it easier to maintain a codebase</li>
        <li> Modules are important from external files with the import statement</li>
        <li> Modules also rely on type="Module" in the script tag</li>
        <li> There are two types of Modules: Named Modules and Default Modules</li>
    </ul>

    <p>
        Hypothetically, it would take the form <b>
            import message from "./message.js"; <br />
            document.getElementById("demo").innerHTML = message();
        </b>
    </p>

    <p> Importing Named Module</p>
    <p id="demo24"></p>


    <h1> JSON - JavaScrip Object Notation</h1>
    <ul>
        <li>
            // JSON stands for JavaScript Object Notation
        </li>
        <li>
            // JSON is a format for storing and transporting data.

        </li>
        <li>
            // JSON is often used when data is sent from the server to the webpage.

        </li>
        <li>
            // JSON is language independent

        </li>
        <li>
            // JSON names require double quotes, JavaScript names do not.
        </li>
    </ul>

    <p>
        A common use of JSON if to use data from a web server and display data on the web page.<br />
        For simplicity, this can be demonstrated using a string as input.<br />
        First, create a JavaScript string containing JSON syntax:
    </p>

    <p id="demo25"></p>


    <h1> Debugging </h1>
    <p> Normally, active debugging capabilities in the browser with the F12 key and select "Console in the debugger menu"</p>
    <p> If the browser supports debugging, we can use console.log()</p>
    <p> On a Mac, we can access debugging by pressing the fn key and then the volume up key.</p>


    <h1> Style Guide </h1>
    <p>
        // It is good to use camelCase for variables and functions, also called identifier names.<br />
        // All names start with a letter. A letter. A letter. Not a number. A letter.<br />
        // Always put spaces around operators and after commas <br />
        // Always use two spaces of indentation for code blocks. <br />
        // DO NOT use tabulators for indentations. Different editors interpret tabs differently.
        // Always put semi colon after simple statements.

        const veggies = ["Carrot", "Squash", "Kale"];

        // General Rules for complex (compound) statements
        // Put opening bracket at end of the first line
        // One space before the first bracket
        // Do not end a complex statement with a semi colon
        // Complex statement example: Functions, Loops, Conditionals. <br />


        function toCelsius(fahrenheit) { <br />
        return (5 / 9) * (fahrenheit - 32); <br />
        } <br />
        <br />
        for (let i = 0; i < 5; i++) { <br />
        x += i; <br />
        } <br />
        <br />
        if (time < 20) { <br />
        greeting = "Good day"; <br />
        } else { <br />
        greeting = "Good evening"; <br />
        }

    </p>

    <h2> Object Rules </h2>
    <ul>
        <li> Place opening bracket on the same line as the object name. </li>
        <li> Use a colon plus one space between each property and its value. </li>
        <li> Use quotes around string values, not numeric values. </li>
        <li> Do <b> NOT </b> add a comma after the last property value pair. </li>
        <li> Place the closing bracket on a new line, without leading spaces. </li>
        <li> Always end an object definition with a semicolon. </li>
    </ul>

    <h2> Line Length </h2>
    <ul>
        <li> Best to keep JavaScript line lengths to under 80. </li>
        <li> Above 80, it is best to break it after a comma or an operator. </li>
    </ul>

    <h2> JavaScript Best Practices </h2>

    <ul>
        <li> Avoid global variables - easily get confused once code starts getting into the thousands. </li>
        <li> Avoid new </li>
        <li> Avoid == </li>
        <li> Avoid eval() </li>
        <li> Always declear variables with let, var, or const - no matter what. </li>
    </ul>

    <h2> Place declarations on the top </h2>
    <ul>
        <li> It is a best practice to put declarations on the top. </li>
        <li> Makes for cleaner code and readability </li>
        <li> The same goes for loop variables! </li>
    </ul>

    <h2> Declare at the beginning </h2>
    <p> <b>let firstName, lastName, price, discount, fullPrice;</b> </p>

    <h2> Use later after declaration at the beginning </h2>
    <p>
        firstName = "John"; <br />
        lastName = "Doe"; <br />

        price = 19.90; <br />
        discount = 0.10; <br />

        fullPrice = price - discount;
    </p>

    <h2>Same concept with declarations applies to loop variables. </h2>

    <p>for (let i = 0; i < 5; i++) { </p>

    <ul>
        <li> It is also good practice to not only declare variables at the beginning of the JS file, but also initiate them with a type and value. </li>
        <li> Initializing variables provides an idea of the intended use (and intended data type). </li>
        <li> Do NOT use new Object() of any kind! </li>
        <li> Declare Arrays and Objects with the const declaration. </li>
    </ul>


    <h2> Important: Using Parameter Defaults </h2>
    <ul>
        <li>Undefined values can break a file of code.</li>
        <li>It is best to assign default values to arguments</li>
    </ul>

    <p>
        function myFunction(x, y) { <br />
        if (y === undefined) { <br />
        y = 0; <br />
        } <br />
        }
    </p>

    <h1> // Example of typical function random practice </h1>
    <p id="demo28"></p>



    <h2> Iterating through a string using for..of</h2>
    <p id="bigdemo"></p>







    <script>const name = "Fitness";

        let bigtext = ""
        for (const x of name) {
            bigtext += x + "<br>";
        }

        document.getElementById("bigdemo").innerHTML = bigtext;</script>


    <h2> Iterating through an array using for..of</h2>
    <p id="bomberdemo"></p>

    <script>// With for..of, the symbolIterator method is called automatically
        const bomberarray = ["Jeter", "Gehrig", "Ruth"]

        let bombertext = ""
        for (const x of bomberarray) {
            bombertext += x + "<br>";
        }

        document.getElementById("bomberdemo").innerHTML = bombertext;

        // Or, we could do the for...of manually, if we wanted.</script>

    <h1> JavaScript Sets </h1>
    <p>
        <ul>
            <li> A JavaScript set is a collection of unique values. </li>
            <li> Each value can only occur once of a set. </li>
            <li> A set can hold any value of any data type. </li>
        </ul>
    </p>

    <h3> How to add a new set? </h3>
    <p>
        <ul>
            <li> Use new Set() </li>
            <li> Create a set and use add() to add values. </li>
            <li> Create a set and use add() to add variables. </li>
        </ul>
    </p>

    <h3>Creating a new set</h3>
    <p id="newset"></p>
    <script>const letters = new Set(["a", "b", "c"]);
        document.getElementById("newset").innerHTML = letters.size;</script>

    <h3> // Creating a set and adding literal values </h3>
    <p></p>
    <script>const endletters = new Set();

        endletters.add("z");
        endletters.add("y");
        endletters.add("x");

        document.getElementById("newset").innerHTML = endletters.size;</script>

    <h3> // Creating a set and adding literal values </h3>
    <p></p>
    <script>const endletters = new Set();

        endletters.add("z");
        endletters.add("y");
        endletters.add("x");

        document.getElementById(" endletterset").innerHTML = endletters.size;</script>


    <h3> forEach() calls a function for each element: </h3>
    <p demo="foreach"> </p>
    <script>//const letters = new Set(["a", "b", "c"]);
        //let txt2 = "";
        //letters.forEach (function(value) {
        //    txt2 += value + "<br>";
        //})

        //document.getElementById("foreach").innerHTML = txt2;</script>

    <h3> The keys method </h3>
    <p>
        <ul>
            <li> Sets do not have keys </li>
            <li> It is equivalent to values()</li>
            <li> This makes them compatible with Maps</li>
        </ul>
    </p>

    <h3> The entries() method </h3>
    <p>
        <ul>
            <li> Sets do not have keys.. </li>
            <li> entries returns [value,value] instead of [key, value]</li>
            <li> This, again, makes them compatible with Maps</li>
        </ul>
    </p>
    <p id="demolition"></p>

    <script>const letters = new Set(["a", "b", "c"]);

        // List all entries
        const iterator = letters.entries();
        let taxt = "";
        for (const entry of iterator) {
            taxt += entry + "<br>";
        }

        document.getElementById("demolition").innerHTML = taxt;</script>

    <h1> JavaScript Maps</h1>
    <ul>
        <li> A map holds key-value pairs where the key can be any data type </li>
        <li> A map remembers the original insertion order of the keys </li>
        <li> A map has a property that sets the size of the map</li>
    </ul>

    <p> You can create a JavaScrtip map by :</p>
    <ul>
        <li> Passing an array to new Map() </li>
        <li> Create a map and use Map.set()</li>
    </ul>

    <h2> new Map()</h2>
    <p> We set an array within a Map()</p>
    <p id="dealsdemo"></p>





    <script>// You can create a new map by passing an Array to the new Map() constuctor

        const deals = new Map([
            ["basic", 10],
            ["pro", 25],
            ["premium", 50]
        ]);

        document.getElementById("dealsdemo").innerHTML = deals.get("pro");</script>

    <p> You can add elements to the Map() using the set() method :</p>
    <p id="dealdemo"></p>

    <script>// We can add elements to the Map() using the set() method
        const deal = new Map();

        deal.set("basic", 10);
        deal.set("pro", 25);
        deal.set("premium", 50);

        document.getElementById("dealdemo").innerHTML = deals.get("basic")</script>


    <p> Using the set method can also be used to change existing Map() values.</p>
    <p id="demodealchange"></p>

    <script>// Using the set method can also be used to change existing Map() values.

        const newdeals = new Map([
            ["basic", 10],
            ["pro", 25],
            ["premium", 50]
        ]);

        newdeals.set("premium", 60);

        document.getElementById("demodealchange").innerHTML = newdeals.get("premium");</script>

    <p> The get() method gets the value of a key in a map</p>
    <p id="brands"></p>

    <script>// The get() method gets the value of a key in a map
        const brands = new Map([
            ["Nike", 100],
            ["Adidas", 200],
            ["Versace", 300]
        ]);

        document.getElementById("brands").innerHTML = brands.get("Adidas");</script>

    <p> The size() property returns the number of elements in a Map()</p>
    <p id="presidents"></p>

    <script>// The size property returns the number of elements in a Map()
        const presidents = new Map([
            ["Barack", 1],
            ["Trump", 2],
            ["Bush", 3]
        ]);

        document.getElementById("presidents").innerHTML = presidents.size;</script>

    <p> The delete() method removes a map element</p>
    <p> The clear() method removes all elements from a map</p>
    <p> Needs to be in map.clear() format</p>
    <br />
    <br />
    <p> The Map.has() method returns true of the map has a particular element</p>
    <p id="seasondemo"></p>
    <script>const seasons = new Map([
            ["fall", 0],
            ["spring", 0],
            ["summer", 9]
        ]);

        document.getElementById("seasondemo").innerHTML = seasons.has("fall");</script>

    <p> To figure out what type of vairable, string, boolean, int, object, we are dealing with, JavaScript uses typeof() method. </p>
    <p> When using the typeof() method on the Map, we get Object. Maps are objecs baby.</p>
    <p> In addition, we see that instanceof() returns true. Instanceof() checks to see if something is an object.</p>

    <h2> Map forEach()</h2>
    <p> The forEach() method invokes a callback for each key/value pair in a Map.</p>
    <p id="fooddemo"></p>
    <script>const food = new Map([
            ["Fries", 100],
            ["Burger", 200],
            ["HotDog", 300]
        ]);

        let message = "";
        food.forEach(function (value, key) {
            message += key + " = " + value + "<br>"
        })

        document.getElementById("fooddemo").innerHTML = message;</script>

    <p> The entries() returns an iterator object with the [key,values] in a Map</p>
    <p id="drinksdemo"></p>
    <script>const drinks = new Map([
            ["Juice", 1],
            ["Water", 2],
            ["Milk", 3]
        ]);

        let drinktext = "";
        for (const x of drinks.entries()) {
            drinktext += x + "<br>";
        }

        document.getElementById("drinksdemo").innerHTML = drinktext;</script>
    <p> The keys() method returns an iterator object with the keys in a Map</p>
    <p> The same with the keys() method returning an iterator object for the keys in a Map, the values() method does so for the values.</p>
    <p> You can also use the values() method to sum the values in a Map</p>
    <br />
    <br />
    <p> Being able to use objects as keys is an important Map feature</p>
    <p> This way, we can add OBJECTS to the Maps</p>
    <p id="objaskeydemo"></p>

    <script>// Creating objects
        const knife = { name: "Knife" };
        const spoon = { name: "Spoon" };
        const fork = { name: "Fork" };

        // Creating a map
        const cutlery = new Map();

        // Adding variables. No, not variables, OBJECTS to the map.
        cutlery.set(knife, 500);
        cutlery.set(spoon, 400);
        cutlery.set(fork, 300);

        document.getElementById("objaskeydemo").innerHTML = cutlery.get(knife);</script>
    <p> It is important to understand that key is an object apple, not a string "apple".</p>

    <h1> JavaScript ES5 Object Methods </h1>
    <p> ECMA5 added alot of new object methods to JS</p>
    <br />
    <p>
        Create objec with an existing object as a prototype:
        Object.create()
    </p>
    <br />
    <p>
        Adding or changing an object property:
        Object.defineProperty(object, property, descriptor)
    </p>
    <br />
    <p>
        Adding or changing object properties:
        OBbject.defineProperties(object, descriptors)
    </p>
    <br />
    <p>
        Accessing properties:
        Object.getOwnPropertyDescriptor(object, property)
    </p>
    <br />
    <p>
        Return all properties as an array:
        Object.getOwnPropertyNames(object)
    </p>
    <br />
    <p>
        Accessing the prototype:
        OBject.getPrototypeOf(Object)
    </p>
    <br />
    <p>
        Returning enumerable properties as an array:
        Object.keys(object)
    </p>
    <br />
    <p> Above are the ways we can manage Objects</p>
    <p> We can also protect Objects. This section is under managing objects within the "Object Reference" tab on W3Schools.com</p>

    <h2>Changing a property value</h2>
    <p>
        // Creating an object
        const person = {
        firstName: "Kyle",
        lastName: "Nunn",
        language: "EN"
        };

        //Defining a property in the object
        Object.defineProperty(person, "language", { value: "YES" });
        document.getElementById("langdemo").innerHTML = person.language;
    </p>

    <h2>Changing Meta Data</h2>
    <p> We can also use defineProperty in other ways too, all working with how we operate with the Objects. </p>
    <p> Below, we will change some of the way Objects operate. </p>

    <p>
        This example makes the Object read only:
        Object.defineProperty(person, "language", { writable: false });

        This example makes language not enumerable:
        Object.defineProperty(person, "language", { enumerable: false });
    </p>

    <p id="langdemo"></p>

    <h2> Listing all properties in an Object </h2>

    <p>
        document.getElementById("alldemo").innerHTML =
        Object.getOwnPropertyNames(person);
    </p>

    <p id="alldemo"></p>

    <h2> This example lists all the enumerable properties of an object: </h2>
    <p>
        document.getElementById("allenum").innerHTML =
        Object.keys(person);
    </p>
    <p id="allenum"></p>

    <h2> We can also add a new property to an object: </h2>
    <p>
        Object.defineProperty(person, "year", { value: "1998" });
        document.getElementById("newyeardemo").innerHTML = person.year;
    </p>
    <p id="newyeardemo"></p>

    <h2> Adding Getters and Setters </h2>
    <p> the Object.defineProperty() method can also be used to define Getters and Setters</p>

    <p id="fulldemo"></p>

    <h2> A counter example with using Getters and Setters</h2>
    <p> We have to define the getters and setters first</p>
    <p id="counterdemo"></p>


    <h1> JavaScript Function Definitions </h1>
    <p> JavaScript Functions are defined with the "function" keyword</p>
    <p> You can use a function declaration and a function expression</p>
    <p> Ealier in the tutorial, we learned that functions are declared with the following syntax:</p>
    <p>
        function (paramters){ <br />
        //code to be executed <br />
        }
    </p>

    <p> Declared functions are not executed immediately. They are saved for later use, and will be executed with invoked, or called upon.</p>
    <p id="newFunction"></p>
    <p> Semi Colons are used to seperate executable JS statement</p>
    <p> Since a function declaration is not an executable statement, it is not common to end it with a semicolon.</p>


    <h2> Function Expressions</h2>
    <p> A JS function can also be defined using an expression</p>
    <p> A function expression can be stored in a variable</p>
    <p id="brandNewFunction"></p>
    <p> After the new function has been stored in a variable, the variable can now be used a function.</p>
    <p> We can also create new variables from those functions.</p>
    <p> Functions sotred in variables do not need variable names, they are always invoke, or called upon, with the variable name.</p>

    <h2> The Function() constructor</h2>
    <p> In previous examples, we have defined JS functions with the "function" keyword</p>
    <p> Functions can also be defined with a built in JavaScript constructor called Function().</p>
    <p id="newestfunc"></p>
    <p> Most of the time, we can avoid using the "new" keyword in JavaScript</p>
    <p> The typeof() operator in JS returns "function" for functions.</p>
    <p> While the above is true, functions can still best be described as objects</p>
    <p> JavaScript functions have both properties and methods. </p>


    <h1> Function Parameters </h1>
    <h2> Function Parameters and Arguments </h2>
    <p> Parameters are the <b>NAMES</b> that come after the function</p>
    <p> Arguments are the <b>values</b> that are actually pushed into the function. Real values. Numbers. Strings.</p>
    <h2> Parameter Rules </h2>
    <p>
        <ul>
            <li> JavaScript function definitions do not specify data types for parameters </li>
            <li> JavaScript function do not perform type checking on the passed arguments</li>
            <li> JavaScript functions do not check the number of arguments received</li>
        </ul>
    </p>

    <h2> Default Parameters </h2>
    <p> If a function is called with missing arguments (less than declared) the missing values are set the <b>undefined.</b> </p>
    <p> Sometimes this is acceptable, but it is better to pass an default value to the missign parameter.</p>
    <br />
    <p> If y is not passed or undefined, then y=10</p>
    <p> Example: </p>
    <p id="yfuncdemo"></p>

    <h2> Function Rest Parameter </h2>
    <p> The rest parameter (...) allows a function to treat an indefinite number of arguments as an array </p>
    <p id="argdemo"></p>

    <h2> The Arguments Object </h2>
    <p> JavaScript functions have a built-in object called the Argument object </p>
    <p> The arg object contains an array of the arguments used when the object was invoked</p>
    <p> This way we can simply use a function to, for example, find the highest value in a list of numbers. </p>
    <p id="maxdemo"></p>
    <p> If a function is called with too many arguments (more than declared), the arguments can be reached using the arguments object</p>

    <h2> Arguments are passed by value</h2>
    <p>The parameters, in a function call, are the functions arguments</p>
    <p> JavaScript arguments are passed by value, the function oly gets to know the values, not the arguments locations</p>
    <p><b>Changes to arguments are not visible, or reflected, outside of the function. </b></p>
    <p><b>Changes to properties are visible outside of the function. </b></p>


    <h1> JavaScript Function Invocation </h1>
    <p> It is often commonplace to hear to call upon or invoke a function used interchangeably </p>
    <p> We will use invoke becuase a function can be invoked without being called </p>
    <p> Take the below JS for example. This function doesn't belong to an object, and thus, "belongs" to the linked html page</p>
    <p>
        <b>
            function myFunction(a, b) { <br />
            return a * b; <br />
            } <br />
            document.getElementById("demo").innerHTML = myFunction(10, 2);
        </b>
    </p>
    <p> In a browser the page object is the browser window. The function above automatically becomes a window function. </p>


    <h2> The Global Object </h2>
    <p> When a function is called without an owner object, the value this becomes the global object</p>
    <p> In a web browser the global object is the browser window</p>
    <p> Using the window object as a variable can easily crash your program</p>


    <h2> Invoking a function as a method </h2>
    <p> In JS you can define functions as object methods </p>


    <h1> JavaScript Function call()</h1>
    <h2> Method reuse </h2>
    <p> With the call() method, you can make a method that can be used on different functions.</p>
    <p> Listen closely, all functions are methods </p>
    <p> In the below example input, the fullName property is a method within an object</p>
    <p id="flnamedemo"></p>


    <h2> The JavaScript call() method</h2>
    <p> The call() method is a predefined JavaScript method</p>
    <p> With call() an object can use a method belonging to another object. It basically just calls the other object and is like aye dog lemme borrow that method from you.</p>


    <h2> JavaScript function apply()</h2>
    <p> With the apply method, you can write a method that can be used on different objects </p>
    <p> The apply method is similar to the call method, Oh Snap!</p>
    <p> In JavaScript strict mode, if the first argument of the apply() method is not an object, it becomes the owner of the invoked function. In "non-strict" mode, it becomes the global object.</p>

    <h1> JavaScript function bind()</h1>
    <p> Sometimes the bind method has to be used to prevent losing "this".</p>
    <p> When a function is used as a callback, "this" is lost.</p>
    <p> The below example code will try to display the person name after 3 seconds, but it will return "undefined" instead:</p>
    <p>
        <b>
            const person = { <br />
            firstName:"John",<br />
            lastName: "Doe", <br />
            display: function() { <br />
            let x = document.getElementById("demo"); <br />
            x.innerHTML = this.firstName + " " + this.lastName; <br />
            } <br />
            } <br />
            <br />
            setTimeout(person.display, 3000);
        </b>
    </p>

    <p> The bind() method solves this problem</p>
    <p> In the following example, the bind() method is used the bind person.display to person.</p>
    <p>
        <b>
            const person = { <br />
            firstName:"John",<br />
            lastName: "Doe",<br />
            display: function() {<br />
            let x = document.getElementById("demo");<br />
            x.innerHTML = this.firstName + " " + this.lastName;<br />
            }<br />
            }<br />
            <br />
            let display = person.display.bind(person);<br />
            setTimeout(display, 3000);
        </b>
    </p>


    <h1> JavaScript Closures</h1>
    <p> Global variables can be made local (private) with closures </p>
    <p> JavaScript variables can belong to the local or global scope</p>
    <p> Global variables can be made local, or private, with closures. </p>

    <h2> Global Variables </h2>
    <p> A function can access all variables defined inside that function, like this:</p>
    <p>
        <b>
            myFunction();<br />

            function myFunction() { <br />
            let a = 4; <br />
            document.getElementById("demo").innerHTML = a * a; <br />
            }<br />
        </b>
    </p>
    <p id="inFunction"></p>

    <p> We can also access variables that were defined outside of the function.</p>
    <p id="outFunction"></p>

    <h2> Variable Lifetime </h2>
    <p> Global variables live until the page is discarded, like when you navigate to another page or close the window </p>
    <p> Local variables have short lives, they are created when a function is invoked. </p>

    <h2> JavaScript Nested Functions </h2>
    <p> All functions have access to the global scope</p>
    <p> In fact, in JavaScript, all functions have access to the scope "above" them.</p>
    <p> JS supports nested functions. Nested functions have access to the scope above them. </p>
    <p> In this example , the inner function plus() has access to the counter variable in the parent function.</p>
    <p>
        <b>
            document.getElementById("demo").innerHTML = add(); <br />
            function add() { <br />
            let counter = 0;<br />
            function plus() {counter += 1;}<br />
            plus();<br />
            return counter;<br />
            }
        </b>
    </p>
    <p id="additiondemo"></p>
    <p> The above code could have solved the counter dilemma </p>
    <p> We need a closure.</p>
    <p id="closureDemo"></p>
    <button type="button" onclick="closureFunction()"> Counter </button>
    <p> A closure is a function having access to the parent scope , even after the parent function has closed.</p>


    <h1> JavaScript Classes</h1>
    <p> JS classes are templates for JS objects</p>
    <p> Use keyword class to create a class</p>
    <p> To a class, always add a method named constructor.</p>
    <p> When using a class, you can use the class to create an object. </p>
    <p><b>Class example:</b></p>
    <p id="brandnewCar"></p>
    <p> JavaScript Class Methods Example:</p>
    <p id="lamboagedemo"></p>
    <p> You can also send parameters into classes </p>
    <p id="lambonewagedemo"></p>

    <h2>// Use "strict"</h2>
    <p>
        // The syntax in classes must be written in "strict mode" <br />
        // You will get an error if you don't follow the strict mode rules <br />
        // You will get an error if you use a variable without declaring it <br />
    </p>
    <p>
        <b>
            class Car { <br />
            constructor(name, year) { <br />
            this.name = name;<br />
            this.year = year;<br />
            <br />
            }<br />
            age() {<br />
            // date = new Date();  // This will not work<br />
            const date = new Date(); // This will work<br />
            return date.getFullYear() - this.year;<br />
            }<br />
            }<br />
            <br />
            const myCar = new Car("Ford", 2014);<br />
            document.getElementById("demo").innerHTML =<br />
            "My car is " + myCar.age() + " years old.";<br />
        </b>
    </p>


    <h1> JavaScript Class Inheritance </h1>
    <h2> Class Inheritance </h2>
    <p> To create a class inheritance, use the extends keyword</p>
    <p> Inheritance Demo:</p>
    <p id="indemo"></p>
    <p>
        // The super method refers to the parent class <br />
        // By calling the super() method in the constructor method, we call the parent's constructor method and get access to the parent's methods and properties <br />
        // Innheritance is good for code reusability. Reuse properties and methods of an existing class when you want to create a new class. <br />
    </p>

    <h2> Getters and Setters </h2>
    <p> Classes also allows you to use Getters and Setters</p>
    <p> It can be smart to use getters and setters in your properties\, especially if you want to do something special with the value before returning them, or before you set them.</p>
    <p> To add getters and setters in the class, just add the get() and set() keywords </p>
    <p> Get Demo:</p>
    <p id="getdemo"></p>

    <h2> Hoisting </h2>
    <p> Unlike functions, and other JS declarations, class declarations are not hosited.</p>
    <p> This means that a class must be declared before we can use it.</p>

    <h2> JavaScript Static Methods </h2>
    <p> Static class methods are defined on the class itself.</p>
    <p> You can't all a static method on an object, only on an object class</p>
    <p> Static Example:</p>
    <p id="staticdemo"></p>

    <p> If you want to use the myCar object inside the static method, you can send it as a parameter:</p>
    <p id="static2demo"></p>

    <h1> JavaScript Callbacks</h1>
    <p> I will call back later!</p>
    <p> A callback function is a function passed as an argument to another function</p>
    <p> This technique allows one function to call another function.</p>
    <p> A callback function can run after another function has finished.</p>

    <h2> Function Sequence </h2>
    <p> Javascript functions are executed in the sequence they are called, not in the sequence they are defined</p>
    <p> Callback demo example:</p>
    <p id="callbackdemo"></p>

    <p> This example will end up saying hello, where the last one said Goodbye</p>
    <h2> Sequence control </h2>
    <p> Sometimes you would like to have better control over when you execute a function.</p>
    <p> Suppose you want to do a calculation, and then display the result. </p>
    <p> We could call a calculator function (myCalculator), save the result, and then call another function, myDisplayer(), to display the result.</p>
    <p> Call back demo2 Example</p>
    <p id="callbackdemo2"></p>
    <p> As an alternative to the above appraoch, we could call the calculator function myCalculator(), and then let the calculator function call the display function myDisplay()</p>
    <p>
        // The problem with the first example above, is that you have to call two functions to display the result<br />
        // The problem with the second example, is that you cannot prevent the calculator function from displaying the result <br />
        // Now, it's time to bring a the CALLBACK BABY!!! <br />
    </p>
    <h2> JavaScript Callbacks </h2>
    <p> A Callback is a function passed as an argument to another function</p>
    <p> Using a callback, you could call the calculator function with a callback function (myCallBack), and let the calculator function run the callback after the calculator function is finished.</p>
    <p> First call back demo</p>
    <p id="firstcallbackdemo"></p>
    <p> Another exmample of a callback with numbers</p>
    <p id="doubledemo"></p>
    <p>
        // In the example above, (x) => x >= 0; is a callback function. <br />
        // It is passed to removeNeg() as an argument. <br />
        // Where callback functions really shine are in asynchronous function, where one function has to wait for another function (like waiting for a file to load) <br />
    </p>

    <h1> Asynchronous JavaScript</h1>
    <p> A Call back will call ya later, but Asynchronous is like, I will finish later. Shows the most important parts of the page first and simultaneously loads the JS Asynchronously. </p>
    <p> This is functions running in parallel with other functions.</p>
    <p> A good example of this is setTimout()</p>
    <p> The examples in the previous chapter were very simplified</p>
    <p> The purpose of the examples was to demonstrate callback functions </p>
    <h2> Waiting for a timeout </h2>
    <p> When using the JavaScript function setTimeout(), you can specify a callback function to be executed on time out. </p>
    <p> setTimeout function example</p>
    <p id="settimeoutdemo"></p>

    <p>
        // In the example above, setFunction is used as a callback. He said - I'll call you later! <br />
        // He said I'll put you in as an argument right now, but I'll call you later! <br />
        // When you pass a function as an argument, remember not to use parenthesis. <br />
        // When you pass a function as an argument, understand that you should not use parenthesis in JS. <br />
        // Instead of passing the name of a function as an argument to that same function, you can always pass a whole function instead.<br />
        //
    </p>

    <h2> Waiting for Intervals:</h2>
    <p> When using the JS Function setInterval(), you can specify a callback function to be executed for each interval.</p>
    <p> When using the JS function setInterval(), you can specify a callback function to be executed for each interval. </p>
    <p> Set Interval Example</p>
    <p><b> Question, how to we convert the JavaScript military time? </b></p>
    <p id="intfunction"></p>
    <p id="convertfunctiondemo"></p>

    <p>
        // Call back alternatives <br />
        // With asynchronous programming, JS programs can start long running tasks, and continue running other taks in parallel. <br />
        // But asynchronous programs are difficult to write and difficult to debug.<br />
        // Because of this, most modern JS async programs don't use callbacks. Instead, modern JS programming uses promises over callbacks. <br />
    </p>


    <h1> JavaScript Promises </h1>
    <p> This is basically saying "I promise a result!"</p>
    <p> "producing code" is code that can take some time</p>
    <p> "Consuming code is code that must wait for the result"</p>
    <p> A promise is a JS object that links producing and consuming code.</p>
    <p> A JS promise object contains both the producing code and calls to the consuming code.</p>
    <p> When the producing code obtains the result, it should call one of the two callbacks:</p>
    <p>
        <ul>
            <li> Result: Success, Call: myResolve(result value)</li>
            <li> Result: Error, Call: myReject(error object)</li>
        </ul>
    </p>
    <p>
        A JS Promise object can be :
        <ul>
            <li>Pending</li>
            <li> Fulfilled</li>
            <li> Rejected </li>
        </ul>
    </p>
    <p> The promise object contaisn two results: state and result</p>
    <p> Pending is undefined</p>
    <p> Fulfilled is result value</p>
    <p> Rejected is an error object </p>
    <p><b> You cannot access the promise properties state and result.</b></p>
    <p> You must use a promise method to handle promises.</p>
    <p> Promise Demo Code: </p>
    <p id="promisedemo"></p>

    <h1> JavaScript async and await make promises easier to write </h1>
    <p> async makes a function return a promise</p>
    <p> await makes a function wait for a promise</p>
    <p> The word async before a function makes the function return a promise </p>
    <p> Async demo:</p>
    <p id="syncdemo"></p>
    <h2> Await Syntax</h2>
    <p> The await keyword can only be used inside an async function</p>
    <p> The await keyword makes the function pause the execution and wait for a resolved promise before it continues.</p>
    <p> Await promise example:</p>
    <p id="awaitpromise"> </p>
    <p> Await waiting for a timeout example:</p>
    <p id="awaitpromisetime"></p>


    <h1> JAVASCRIPT HTML DOM</h1>
    <P> When a web page is loaded, the browser creates a Document Object Model of that page</P>
    <p> The HTML DOM method is constructed as a tree of objects.</p>
    <p> The W3C dom standard is seperated into three different types: HTML DOM, XML DOM, and Core DOM.</p>
    <p> It is imporatnt to note that we have methods and properties in JS</p>
    <p> getElementById is a method and innerHTML is a property.</p>
    <p> The most common way to access an HTML element is to use the id of the element.</p>
    <p> The easiest way to get the content of an HTML element is to use the innerHTML property</p>
    <p> The innerHTML property can be used to get or change any HTML element including html or body</p>
    <p> Often, with JavaScript, you want to manipulated HTML elements </p>
    <p> To do this, we have to find the elements first.</p>



    <h1> JavaScript Forms </h1>
    <h2> JavaScript Form Validation</h2>
    <p> From this point forward, this HTML document will be using an external JS file.</p>
    <p> HTML form validation can be done by JS.</p>
    <p> If a form field (fname) is empty, this function alerts a message, and returns false, and prevents the form from being submitted to say a PHP or Node.js document.</p>

  <form name="nameForm" action="" onsubmit="return validformFunction()" method="post">
      Name: <input type="text" name="fname" />
      <input type="submit" value="Submit" />
  </form>

    <p><i>Note:</i> Everytime the user is inputting anything whether it be text or their mouse input, there needs to be an input element for that input.</p>











































    <script>// Creating an object
        const person = {
            firstName: "Kyle",
            lastName: "Nunn",
            language: "EN"
        };

        //Defining a property in the object
        Object.defineProperty(person, "language", { value: "YES" });
        document.getElementById("langdemo").innerHTML = person.language;

        // <h2>Changing Meta Data</h2>
        //  <p> We can also use defineProperty in other ways too, all working with how we operate with the Objects. </p>
        // <p> Below, we will change some of the way Objects operate. </p>

        //This example makes the Object read only:
        Object.defineProperty(person, "language", { writable: false });

        //This example makes language not enumerable:
        Object.defineProperty(person, "language", { enumerable: false });



        // <h2> Listing all properties in an Object </h2>
        document.getElementById("alldemo").innerHTML =
            Object.getOwnPropertyNames(person);

        // <h2> This example lists all the enumerable properties of an object: </h2>
        document.getElementById("allenum").innerHTML =
            Object.keys(person);

        // We can also add a new property to an object:
        Object.defineProperty(person, "year", { value: "1998" });
        document.getElementById("newyeardemo").innerHTML = person.year;

        // <p> the Object.defineProperty() method can also be used to define Getters and Setters</p>
        // Example:

        Object.defineProperty(person, "fullName", {
            get: function () { return this.firstName + " " + this.lastName; }
        });

        document.getElementById("fulldemo").innerHTML = person.fullName;

        //  <h2> A counter example with using Getters and Setters</h2>
        const obj = { counter: 0 };

        Object.defineProperty(obj, "reset", {
            get: function () { this.counter = 0; }
        });
        Object.defineProperty(obj, "increment", {
            get: function () { this.counter++; }
        });
        Object.defineProperty(obj, "decrement", {
            get: function () { this.counter--; }
        });
        Object.defineProperty(obj, "add", {
            set: function (value) { this.counter += value; }
        });
        Object.defineProperty(obj, "subtract", {
            set: function (value) { this.counter -= value; }
        });

        obj.reset;
        obj.add = 9;
        obj.subtract = 3;
        obj.increment;
        obj.increment;

        document.getElementById("counterdemo").innerHTML = obj.counter;</script>

    <script>// This Script is for the Functions group
        // <p> JavaScript Functions are defined with the "function" keyword</p>
        // <p> You can use a function declaration and a function expression</p>
        //  <p> Ealier in the tutorial, we learned that functions are declared with the following syntax:</p>
        //  <p> function (paramters){ <br />
        //code to be executed <br />
        //  }
        // </p>

        // <p> Declared functions are not executed immediately. They are saved for later use, and will be executed with invoked, or called upon.</p>
        // Example:

        function newFunction(a, b) {
            return a * b;
        }

        let x = newFunction(4, 5);
        document.getElementById("newFunction").innerHTML = x;


                                               // <h2> Function Expressions</h2>
                                            // <p> A JS function can also be defined using an expression</p>
                                            // <p> A function expression can be stored in a variable</p>
                                            cosnt y = function (i, j) { return i * j };
        document.getElementById("brandNewFunction").innerHTML = y;

        // <p> After the new function has been stored in a variable, the variable can now be used a function.</p>
        //<p> We can also create new variables from those functions.</p>
        //<p> Functions sotred in variables do not need variable names, they are always invoke, or called upon, with the variable name.</p>

        //<h2> The Function() constructor</h2>
        //<p> In previous examples, we have defined JS functions with the "function" keyword</p>
        //<p> Functions can also be defined with a built in JavaScript constructor called Function().</p>

        const myNewestFunction = new Function("a", "b", "return a * b");
        document.getElementById("newestfunc").innerHTML = myNewestFunction(20, 30);


        // <p> Most of the time, we can avoid using the "new" keyword in JavaScript</p>
        //  <p> The typeof() operator in JS returns "function" for functions.</p>
        //  <p> While the above is true, functions can still best be described as objects</p>


        //<h1> Function Parameters </h1>
        //<h2> Function Parameters and Arguments </h2>
        //<p> Parameters are the <b>NAMES</b> that come after the function</p>
        //<p> Arguments are the <b>values</b> that are actually pushed into the function. Real values. Numbers. Strings.</p>
        //<h2> Parameter Rules </h2>
        //<p>
        //<ul>
        // <li> JavaScript function definitions do not specify data types for parameters </li>
        // <li> JavaScript function do not perform type checking on the passed arguments</li>
        // <li> JavaScript functions do not check the number of arguments received</li>
        // </ul>
        // </p></script>

    <script>// <h2> Default Parameters </h2>
        // <p> If a function is called with missing arguments (less than declared) the missing values are set the <b>undefined.</b> </p>
        // <p> Sometimes this is acceptable, but it is better to pass an default value to the missign parameter.</p>
        // <br />
        // <p> Example: </p>


        function yFunction(x, y = 10) {
            return x + y;
        }

        document.getElementById("yfuncdemo").innerHTML = yFunction(5);

        // The rest parameter (...) allows a function to treat an indefinite number of arguments into an array

        function sum(...args) {
            let sum = 0;
            for (let arg of args) sum += arg;
            return sum;
        }

        let x = sum(1, 2, 3, 4, 5, 6, 7);

        document.getElementById("argdemo").innerHTML = x;

        /// Using arguments object to find the highest value in an arary:
        function findMax() {
            let max = -Infinity;
            for (let i = 0; i < arguments.length; i++) {
                if (arguments[i] > max) {
                    max = arguments[i];
                }
            }
            return max;
        }
        document.getElementById("maxdemo").innerHTML = findMax(4, 10, 6);

        const theObject = {
            fName: "Babe",
            lName: "Ruth",
            flname: function () {
                return this.fName + " " + this.lName;
            }
        }
        document.getElementById("flnamedemo").innerHTML = theObject.flname();

        // <h1> JavaScript function bind()</h1>
        //<p> Sometimes the bind method has to be used to prevent losing "this".</p>
        // <p> When a function is used as a callback, "this" is lost.</p>
        // <p> The below example code will try to display the person name after 3 seconds, but it will return "undefined" instead:</p>

        //const dude = {
        //    firName: "Big",
        //    lasName: "Lebowski",
        //    display: function () {
        //        let x = document.getElementById("thedude");
        //        x.innerHTML = this.firName + " " + this.lasName;
        //    }
        //}

        //setTimeout(person.display, 3000);

        //   <p> The bind() method solves this problem</p>
        //  <p> In the following example, the bind() method is used the bind person.display to person:</p>


        const person = {
            firstName: "John",
            lastName: "Doe",
            display: function () {
                let x = document.getElementById("binddemo");
                x.innerHTML = this.firstName + " " + this.lastName;
            }
        }

        let display = person.display.bind(person);
        setTimeout(display, 3000);</script>

    <script>// A function can access variables defined inside the function, like this:
        insideFunction();

        function insideFunction() {
            let a = 4;
            document.getElementById("inFunction").innerHTML = a * a;
        }

        // But a function  can also access variables defined outside of the function, like this:
        let b = 5;
        outsideFunction();


        function outsideFunction() {
            document.getElementById("outFunction").innerHTML = b;

        }

        function add() {
            let counter = 0;
            function plus() { counter = + 1; }
            plus();
            return counter;
        }
        document.getElementById("additiondemo").innerHTML = add();


        // <p> The above code could have solved the counter dilemma </p>
        // <p> We need to closure.</p>

        const addit = (function () {
            let counter = 0;
            return function () { counter += 1; return counter; }
        })();

        function closureFunction() {
            document.getElementById("closureDemo").innerHTML = addit();
        }</script>
    <script>//<h1> JavaScript Classes</h1>
        //<p> JS classes are templates for JS objects</p>
        //<p> Use keyword class to create a class</p>
        //<p> To a class, always add a method named constructor.</p>

        class Car {
            constructor(carname, caryear) {
                this.carname = carname;
                this.caryear = caryear;
            }
            age() {
                const date = new Date();
                return date.getFullYear() - this.caryear;
            }
        }

        // The example above creates a class named Car
        // It has two initial properties, carname and caryear
        // JavaScript class is not an object, but a template for an object
        // When you have a class, you can use the class to create JS objects
        // In the below example, we'll work from the above create Car class

        //const myCar1 = { carname: "Lambo", caryear= 2020 };
        //const myCar2 = { carname: "Ferrari", caryear = 2019 };
        const myCar1 = new Car("Lambo", 2018);
        const myCar2 = new Car("Ferrari", 2018);

        document.getElementById("brandnewCar").innerHTML = "I will have a " + myCar1.carname + " and a " + myCar2.carname;



        // The above example uses the Car class to create two car Objects
        // The constructor method is called automatically when a new object is created
        // The Constructor Method
        // The constructor method is a special method:
        // It has to have the exact name "Constructor"
        // It is executed automatically when a new object is created
        // It is used to initialize object properties
        // If a constructor method is not defined, JS will auto define it
        // class methods are created with the same syntax as object methods
        // Use keyword class to create a class
        // Always add a constructor method
        // Then add any number of methods:

        // Example

        // class Classname {
        // constructor() {... }
        // method1(){... }
        // method2(){...}
        // }

        // Creating a class method Age that returns the cars age
        // We will input the method age into the original code at the top of this script
        // Will we use the original cars Lambo and Ferrari as classes

        document.getElementById("lamboagedemo").innerHTML = "The lambo is " + myCar1.age() + " years old. ";

        // We can also send parameters to class methods:
        // We'll pass a parameter into the age method above:

        class Cars {
            constructor(name, year) {
                this.name = name;
                this.year = year;
            }
            age(x) {
                return x - this.year;
            }
        }

        const date = new Date();
        let year = date.getFullYear();

        document.getElementById("lambonewagedemo").innerHTML = "The lambo is still " + myCar1.age(year) + " years old. ";

        // Use "strict"
        // The syntax in classes must be written in "strict mode"
        // You will get an error if you don't follow the strict mode rules
        // You will get an error if you use a variable without declaring it</script>

    <script>// <h1> JavaScript Class Inheritance </h1>
        // <h2> Class Inheritance </h2>
        // <p> To create a class inheritance, use the extends keyword</p>
        // A class created with a class inheritance inherits all the methods from another class:
        // The "super" method to call the parents constructor function, in this case, brand.

        class forCar {
            constructor(brand) {
                this.carname = brand;
            }
            present() {
                return "I have a " + this.carname;
            }
        }

        class Model extends forCar {
            constructor(brand, mod) {
                super(brand);
                this.Model = mod;
            }
            show() {
                return this.present() + ", It is a " + this.model;
            }
        }
        const myCar = new Model("Lambo", "Huracan");
        document.getElementById("indemo").innerHTML = myCar.show();

        // The super method refers to the parent class
        // By calling the super() method in the constructor method, we call the parent's constructor method and get access to the parent's methods and properties
        // Innheritance is good for code reusability. Reuse properties and methods and an existing class when you want to create a new class.</script>
    <script>// <h2> Getters and Setters </h2>
        // <p> Classes also allows you to use Getters and Setters</p>
        // <p> It can be smart to use getters and setters in your properties\, especially if you want to do something special with the value before returning them, or before you set them.</p>
        // <p> To add getters and setters in the class, just add the get() and set() keywords </p>

        // Create a getter and setter for the "carname" property

        class lambCar {
            constructor(brand) {
                this.carname = brand;
            }
            get cnam() {
                return this.carname;
            }
            set cnam(x) {
                this.carname = x;
            }
        }
        const theCar = new lambCar("Ferrari");
        document.getElementById("getdemo").innerHTML = theCar.cnam;

        // In the same JavaScript that is connected to the same HTML, you have to change the constant object and class. You can't have two of the same.
        // Maybe you can, but the text wasn't showing up in the HTML with the same Car class and myCar object defined the same as above.
        // Even if the getter is a method, you do not use paranthesis when you want to use the property value.
        // The name of the getter setter method cannot be the same as the name of the property, in this case, carname.
        // Many programmers use an underscore character "_" before the property name the seperate the getter/setter from the actual property:


        // <h2> Hoisting </h2>
        // <p> Unlike functions, and other JS declarations, class declarations are not hosited.</p>
        // <p> This means that a class must be declared before we can use it.</p></script>
    <script>//<h2> JavaScript Static Methods </h2>
        //<p> Static class methods are defined on the class itself.</p>
        //<p> You can't all a static method on an object, only on an object class</p>

        class Ride {
            constructor(name) {
                this.name = name;
            }
            static hello() {
                return "What's crackalackin!?";
            }
        }

        const oldCar = new Ride("Pontiac");

        document.getElementById("staticdemo").innerHTML = Ride.hello();
        // Here, we called hello() static method on the Ride class.
        // We would not have been able to call it on the oldCar object.
        // If we want to use the oldCar object inside the static method, you can send it as a parameter:

        class slowRide {
            constructor(name) {
                this.name = name;
            }
            static hello(x) {
                return "Hey There, " + x.name;
            }
        }

        const Whip = new slowRide("Cruier");

        document.getElementById("static2demo").innerHTML = Ride.hello(Whip);</script>
    <script>//  <h1> JavaScript Callbacks</h1>
        //  <p> I will call back later!</p>
        //  <p> A callback function is a function passed as an argument to another function</p>
        //  <p> This technique allows one function to call another function.</p>
        //  <p> A callback function can run after another function has finished.</p>

        //  <h2> Function Sequence </h2>
        //  <p> Javascript functions are executed in the sequence they are called, not in the sequence they are defined</p>

        function myDisplayer(some) {
            document.getElementById("callbackdemo").innerHTML = some;
        }

        function myFirst() {
            myDisplayer("Hello");
        }

        function mySecond() {
            myDisplayer("Googbye");
        }

        mySecond();
        myFirst();


        // <p> This example will end up saying hello, where the last one said Goodbye</p>
        // If we switch the two functions, the display will by Hello. We just have to switch myFirst and mySecond. Functions are displayed in the order they are called.

        // <h2> Sequence control </h2>
        // <p> Sometimes you would like to have better control over when you execute a function.</p>
        // <p> Suppose you want to do a calculation, and then display the result. </p>
        // <p> We could call a calculator function (myCalculator), save the result, and then call another function, myDisplayer(), to display the result.</p>


        function myDisplayer(something) {
            document.getElementById("callbackdemo2").innerHTML = something;
        }

        function myCalculator(num1, num2) {
            let sum = num1 * num2;
            myDisplayer(sum);
        }

        myCalculator(8, 6);


        // <p> As an alternative to the above appraoch, we could call the calculator function myCalculator(), and then let the calculator function call the display function myDisplay()</p>
        // The problem with the first example above, is that you have to call two functions to display the result
        // The problem with the second example, is that you cannot prevent the calculator function from displaying the result
        // Now, it's time to bring a the CALLBACK BABY!!!

        //<h2> JavaScript Callbacks </h2>
        //<p> A Callback is a function passed as an argument to another function</p>
        //<p> Using a callback, you could call the calculator function with a callback function (myCallBack), and let the calculator function run the callback after the calculator function is finished.</p>


        // CallBack Example
        function myDisplayer1(thing) {
            document.getElementById("firstcallbackdemo").innerHTML = thing;
        }

        function mySecondCalc(numero1, numero2, callBack) {
            let newsum = numero1 + numero2;
            callBack(newsum);
        }

        mySecondCalc(7, 6, myDisplayer1);

        // In the example above, myDisplayer1 is an example of a callback function
        // It is passed to mySecondCalc as an argument
        // When you pass a function as an argument, remember that we do not use parenthesis here.


        // Another useful example
        const myNumbers = [2, -3, 4, 5, -10, 9];

        const posNumbers = removeNeg(myNumbers, (x) => x >= 0);
        document.getElementById("doubledemo").innerHTML = posNumbers;

        // Keeping only positive numbers
        function removeNeg(numbers, callback) {
            const myArray = [];
            for (const x of numbers) {
                if (callback(x)) {
                    myArray.push(x);
                }
            }
            return myArray;
        }

        // In the example above, (x) => x >= 0; is a callback function.
        // It is passed to removeNeg() as an argument.
        // Where callback functions really shine are in asynchronous function, where one function has to wait for another function (like waiting for a file to load)

        //<h1> Asynchronous JavaScript</h1>
        //<p> A Call back will call ya later, but Asynchronous is like, I will finish later. Shows the most important parts of the page first and simultaneously loads the JS Asynchronously. </p>
        //<p> This is functions running in parallel with other functions.</p>
        //<p> A good example of this is setTimout()</p>
        //<p> The examples in the previous chapter were very simplified</p>
        //<p> The purpose of the examples was to demonstrate callback functions </p>
        //<h2> Waiting for a timeout </h2>
        //<p> When using the JavaScript function setTimeout(), you can specify a callback function to be executed on time out. </p>
        //<p> setTimeout function example</p>

        setTimeout(setFunction, 5000);
        function setFunction() {
            document.getElementById("settimeoutdemo").innerHTML = "Hey Baby!";
        }

        // In the example above, setFunction is used as a callback. He said - I'll call you later!
        // He said I'll put you in as an argument right now, but I'll call you later!
        // When you pass a function as an argument, remember not to use parenthesis.
        // When you pass a function as an argument, understand that you should not use parenthesis in JS.
        // Instead of passing the name of a function as an argument to that same function, you can always pass a whole function instead.


        // Waiting for intervals
        // When using the JavaScript function setInterval(), you can specify a callback function to be executed for each interval

        // Example
        setInterval(intFunction, 1000);
        // This is setting an interval for the intFunction function every second. JS represents time in milliseconds

        function intFunction() {
            let d = new Date();
            document.getElementById("intfunction").innerHTML =
                d.getHours() + ":" +
                d.getMinutes() + ":" +
                d.getSeconds();

        }

        // In the above example, the intFunction() is used as a callback
        // intFunction() is passed to the setInterval() as an argument. Notice the lack of parenthesis.
        // It works as a clock becuase setInterval  works every 1 secondd, so the program is giving off the decpetion of a clock. It is a clock.

        // Call back alternatives
        // With asynchronous programming, JS programs can start long running tasks, and continue running other taks in parallel.
        // But asynchronous programs are difficult to write and difficult to debug.
        // Because of this, most modern JS async programs don't use callbacks. Instead, modern JS programming uses promises over callbacks.</script>
    <script>//<h1> JavaScript Promises </h1>
        //<p> This is basically saying "I promise a result!"</p>
        //<p> "producing code" is code that can take some time</p>
        //<p> "Consuming code is code that must wait for the result"</p>
        //<p> A promise is a JS object that links producing and consuming code.</p>
        //<p> A JS promise object contains both the producing code and calls to the consuming code.</p>
        //<p> Example Promise Syntax </p>

        //let myPromise = new Promise(function (myResolve, myReject) {
        //    // producing code may take some time

        //    myResolve(); // When successful
        //    myReject(); // When error surfaces
        //});

        //// Consuming code, must wait for the fulfilled promise
        //myPromise.then(
        //    function (value) {//Code if successful },
        //        function(error) {//Code if error }
        //);

        // then method of the promise takes up two arguments: the callback functions for both the fulfilled and rejected promises.
        // Promise.then() takes two arguments, the successful callback and the failure callback
        // Both are optional, so you can add a callback for success and failure or just one.

        // JavaScript Promise examples: waiting for a timeout or waiting for a file
        // Waiting for a timeout:
        // Example using promise with timeout:

        const myPromise = new Promise(function (Resolve, Reject) {
            setTimeout(function () { Resolve("Hey There!"); }, 5000);
        })
        myPromise.then(function (value) {
            document.getElementById("promisedemo").innerHTML = value;
        })


        //< h1 > JavaScript async and await make promises easier to write </h1 >
        //<p> async makes a function return a promise</p>
        //<p> await makes a function wait for a promise</p>
        //<p> The word async before a function makes the function return a promise </p>

        // async function() myFunction{
        // return "Hello";
        // is the same as
        // function() myFunction{
        // return Promise.resolve("Hello");
        //}

        function syncDisplay(some) {
            document.getElementById("syncdemo").innerHTML = some;
        }
        async function mineFunction() { return "Sup bruh"; }

        mineFunction().then(
            function (value) { syncDisplay(value); }
        );

        //<h2> Await Syntax</h2>
        //<p> The await keyword can only be used inside an async function</p>
        //<p> The await keyword makes the function pause the execution and wait for a resolved promise before it continues.</p>
        // The two arguments (resolve and reject) are predefined by JS - we don't need to recreate them.

        async function newDisplay() {
            let newPromise = new Promise(function (resolve) {
                resolve("Love you man!")
            });
            document.getElementById("awaitpromise").innerHTML = await newPromise;
        }
        newDisplay();

        // Await waiting for a timeout

        async function timeDisplay() {
            let waitPromise = new Promise(function (resolve) {
                setTimeout(function () { resolve("hot dog hot dog hot diggity dog"); }, 3000);
            });
            document.getElementById("awaitpromisetime").innerHTML = await waitPromise;
        }
        timeDisplay();


            //</script>




</body>
</html>

